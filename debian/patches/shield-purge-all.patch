Subject: Ensure shield-purge visits all records in the database
Forwarded: no
Author: Jonathan Niehof <jtniehof@gmail.com>
Last-Update: 2010-04-19
--- a/shield_purge.c
+++ b/shield_purge.c
@@ -170,16 +170,20 @@
 static void purge_db(void) {
 _pam_shield_db_rec_t *record;
 datum key, next_key, data;
+int deleted=0; /*If any key deleted, order changes; must revisit all keys*/
 
 	key = gdbm_firstkey(dbf);
 
 	while(key.dptr != NULL) {
 		data = gdbm_fetch(dbf, key);
+		next_key = gdbm_nextkey(dbf, key);
 
 		if (data.dptr == NULL) {
 			logmsg(LOG_DEBUG, "cleaning up empty key");
-			if (!(options & OPT_DRYRUN))
+			if (!(options & OPT_DRYRUN)) {
 				gdbm_delete(dbf, key);
+				deleted=1;
+			}
 		} else {
 			record = (_pam_shield_db_rec_t *)data.dptr;
 
@@ -187,8 +191,10 @@
 			if (expire_record(record)) {
 				if (!record->count) {
 					logmsg(LOG_DEBUG, "expiring entry");
-					if (!(options & OPT_DRYRUN))
+					if (!(options & OPT_DRYRUN)) {
 						gdbm_delete(dbf, key);
+						deleted=1;
+					}
 				} else {
 					logmsg(LOG_DEBUG, "storing updated entry");
 					if (!(options & OPT_DRYRUN))
@@ -197,9 +203,12 @@
 			}
 			free(data.dptr);
 		}
-		next_key = gdbm_nextkey(dbf, key);
 		free(key.dptr);
 		key = next_key;
+		if (deleted && !key.dptr) {
+			deleted=0;
+			key = gdbm_firstkey(dbf);
+		}
 	}
 }
 
